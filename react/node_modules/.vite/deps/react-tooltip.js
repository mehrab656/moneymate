import {
  require_classnames
} from "./chunk-7VW7ALUX.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  offset,
  shift
} from "./chunk-KQ45HJPJ.js";
import {
  require_react
} from "./chunk-4UQS7KPA.js";
import {
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/react-tooltip/dist/react-tooltip.min.mjs
var import_react = __toESM(require_react(), 1);
var import_classnames = __toESM(require_classnames(), 1);
var h = "react-tooltip-core-styles";
var w = "react-tooltip-base-styles";
var b = { core: false, base: false };
function S({ css: e2, id: t2 = w, type: o2 = "base", ref: r2 }) {
  var l2, n2;
  if (!e2 || "undefined" == typeof document || b[o2])
    return;
  if ("core" === o2 && "undefined" != typeof process && (null === (l2 = null === process || void 0 === process ? void 0 : process.env) || void 0 === l2 ? void 0 : l2.REACT_TOOLTIP_DISABLE_CORE_STYLES))
    return;
  if ("base" !== o2 && "undefined" != typeof process && (null === (n2 = null === process || void 0 === process ? void 0 : process.env) || void 0 === n2 ? void 0 : n2.REACT_TOOLTIP_DISABLE_BASE_STYLES))
    return;
  "core" === o2 && (t2 = h), r2 || (r2 = {});
  const { insertAt: c2 } = r2;
  if (document.getElementById(t2))
    return void console.warn(`[react-tooltip] Element with id '${t2}' already exists. Call \`removeStyle()\` first`);
  const i2 = document.head || document.getElementsByTagName("head")[0], s2 = document.createElement("style");
  s2.id = t2, s2.type = "text/css", "top" === c2 && i2.firstChild ? i2.insertBefore(s2, i2.firstChild) : i2.appendChild(s2), s2.styleSheet ? s2.styleSheet.cssText = e2 : s2.appendChild(document.createTextNode(e2)), b[o2] = true;
}
function E({ type: e2 = "base", id: t2 = w } = {}) {
  if (!b[e2])
    return;
  "core" === e2 && (t2 = h);
  const o2 = document.getElementById(t2);
  "style" === (null == o2 ? void 0 : o2.tagName) ? null == o2 || o2.remove() : console.warn(`[react-tooltip] Failed to remove 'style' element with id '${t2}'. Call \`injectStyle()\` first`), b[e2] = false;
}
var g = (e2, t2, o2) => {
  let r2 = null;
  const l2 = function(...l3) {
    const n2 = () => {
      r2 = null, o2 || e2.apply(this, l3);
    };
    o2 && !r2 && (e2.apply(this, l3), r2 = setTimeout(n2, t2)), o2 || (r2 && clearTimeout(r2), r2 = setTimeout(n2, t2));
  };
  return l2.cancel = () => {
    r2 && (clearTimeout(r2), r2 = null);
  }, l2;
};
var _ = "DEFAULT_TOOLTIP_ID";
var A = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} };
var O = (0, import_react.createContext)({ getTooltipData: () => A });
var T = ({ children: t2 }) => {
  const [n2, c2] = (0, import_react.useState)({ [_]: /* @__PURE__ */ new Set() }), [i2, s2] = (0, import_react.useState)({ [_]: { current: null } }), a2 = (e2, ...t3) => {
    c2((o2) => {
      var r2;
      const l2 = null !== (r2 = o2[e2]) && void 0 !== r2 ? r2 : /* @__PURE__ */ new Set();
      return t3.forEach((e3) => l2.add(e3)), { ...o2, [e2]: new Set(l2) };
    });
  }, u = (e2, ...t3) => {
    c2((o2) => {
      const r2 = o2[e2];
      return r2 ? (t3.forEach((e3) => r2.delete(e3)), { ...o2 }) : o2;
    });
  }, d = (0, import_react.useCallback)((e2 = _) => {
    var t3, o2;
    return { anchorRefs: null !== (t3 = n2[e2]) && void 0 !== t3 ? t3 : /* @__PURE__ */ new Set(), activeAnchor: null !== (o2 = i2[e2]) && void 0 !== o2 ? o2 : { current: null }, attach: (...t4) => a2(e2, ...t4), detach: (...t4) => u(e2, ...t4), setActiveAnchor: (t4) => ((e3, t5) => {
      s2((o3) => {
        var r2;
        return (null === (r2 = o3[e3]) || void 0 === r2 ? void 0 : r2.current) === t5.current ? o3 : { ...o3, [e3]: t5 };
      });
    })(e2, t4) };
  }, [n2, i2, a2, u]), p = (0, import_react.useMemo)(() => ({ getTooltipData: d }), [d]);
  return import_react.default.createElement(O.Provider, { value: p }, t2);
};
function k(e2 = _) {
  return (0, import_react.useContext)(O).getTooltipData(e2);
}
var C = ({ tooltipId: t2, children: o2, className: r2, place: l2, content: n2, html: s2, variant: a2, offset: u, wrapper: d, events: p, positionStrategy: v, delayShow: m, delayHide: f }) => {
  const { attach: h2, detach: w2 } = k(t2), b2 = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => (h2(b2), () => {
    w2(b2);
  }), []), import_react.default.createElement("span", { ref: b2, className: (0, import_classnames.default)("react-tooltip-wrapper", r2), "data-tooltip-place": l2, "data-tooltip-content": n2, "data-tooltip-html": s2, "data-tooltip-variant": a2, "data-tooltip-offset": u, "data-tooltip-wrapper": d, "data-tooltip-events": p, "data-tooltip-position-strategy": v, "data-tooltip-delay-show": m, "data-tooltip-delay-hide": f }, o2);
};
var L = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
var R = (e2) => {
  if (!(e2 instanceof HTMLElement || e2 instanceof SVGElement))
    return false;
  const t2 = getComputedStyle(e2);
  return ["overflow", "overflow-x", "overflow-y"].some((e3) => {
    const o2 = t2.getPropertyValue(e3);
    return "auto" === o2 || "scroll" === o2;
  });
};
var x = (e2) => {
  if (!e2)
    return null;
  let t2 = e2.parentElement;
  for (; t2; ) {
    if (R(t2))
      return t2;
    t2 = t2.parentElement;
  }
  return document.scrollingElement || document.documentElement;
};
var N = async ({ elementReference: e2 = null, tooltipReference: t2 = null, tooltipArrowReference: o2 = null, place: r2 = "top", offset: l2 = 10, strategy: n2 = "absolute", middlewares: c2 = [offset(Number(l2)), flip({ fallbackAxisSideDirection: "start" }), shift({ padding: 5 })], border: i2 }) => {
  if (!e2)
    return { tooltipStyles: {}, tooltipArrowStyles: {}, place: r2 };
  if (null === t2)
    return { tooltipStyles: {}, tooltipArrowStyles: {}, place: r2 };
  const s2 = c2;
  return o2 ? (s2.push(arrow({ element: o2, padding: 5 })), computePosition(e2, t2, { placement: r2, strategy: n2, middleware: s2 }).then(({ x: e3, y: t3, placement: o3, middlewareData: r3 }) => {
    var l3, n3;
    const c3 = { left: `${e3}px`, top: `${t3}px`, border: i2 }, { x: s3, y: a2 } = null !== (l3 = r3.arrow) && void 0 !== l3 ? l3 : { x: 0, y: 0 }, u = null !== (n3 = { top: "bottom", right: "left", bottom: "top", left: "right" }[o3.split("-")[0]]) && void 0 !== n3 ? n3 : "bottom", d = i2 && { borderBottom: i2, borderRight: i2 };
    let p = 0;
    if (i2) {
      const e4 = `${i2}`.match(/(\d+)px/);
      p = (null == e4 ? void 0 : e4[1]) ? Number(e4[1]) : 1;
    }
    return { tooltipStyles: c3, tooltipArrowStyles: { left: null != s3 ? `${s3}px` : "", top: null != a2 ? `${a2}px` : "", right: "", bottom: "", ...d, [u]: `-${4 + p}px` }, place: o3 };
  })) : computePosition(e2, t2, { placement: "bottom", strategy: n2, middleware: s2 }).then(({ x: e3, y: t3, placement: o3 }) => ({ tooltipStyles: { left: `${e3}px`, top: `${t3}px` }, tooltipArrowStyles: {}, place: o3 }));
};
var $ = (e2) => null !== e2 && "object" == typeof e2;
var I = (e2, t2) => {
  if (!$(e2) || !$(t2))
    return e2 === t2;
  const o2 = Object.keys(e2), r2 = Object.keys(t2);
  return o2.length === r2.length && o2.every((o3) => {
    const r3 = e2[o3], l2 = t2[o3];
    return $(r3) && $(l2) ? I(r3, l2) : r3 === l2;
  });
};
var j = { tooltip: "core-styles-module_tooltip__3vRRp", fixed: "core-styles-module_fixed__pcSol", arrow: "core-styles-module_arrow__cvMwQ", noArrow: "core-styles-module_noArrow__xock6", clickable: "core-styles-module_clickable__ZuTTB", show: "core-styles-module_show__Nt9eE", closing: "core-styles-module_closing__sGnxF" };
var B = { tooltip: "styles-module_tooltip__mnnfp", arrow: "styles-module_arrow__K0L3T", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
var z = ({ forwardRef: t2, id: l2, className: n2, classNameArrow: s2, variant: u = "dark", anchorId: d, anchorSelect: p, place: v = "top", offset: m = 10, events: h2 = ["hover"], openOnClick: w2 = false, positionStrategy: b2 = "absolute", middlewares: S2, wrapper: E2, delayShow: _2 = 0, delayHide: A2 = 0, float: O2 = false, hidden: T2 = false, noArrow: C2 = false, clickable: R2 = false, closeOnEsc: $2 = false, closeOnScroll: z2 = false, closeOnResize: D2 = false, openEvents: q2, closeEvents: H2, globalCloseEvents: M, imperativeModeOnly: W, style: P, position: V, afterShow: F, afterHide: K, content: U, contentWrapperRef: X, isOpen: Y, defaultIsOpen: G = false, setIsOpen: Z, activeAnchor: J, setActiveAnchor: Q, border: ee, opacity: te, arrowColor: oe, role: re = "tooltip" }) => {
  var le;
  const ne = (0, import_react.useRef)(null), ce = (0, import_react.useRef)(null), ie = (0, import_react.useRef)(null), se = (0, import_react.useRef)(null), ae = (0, import_react.useRef)(null), [ue, de] = (0, import_react.useState)({ tooltipStyles: {}, tooltipArrowStyles: {}, place: v }), [pe, ve] = (0, import_react.useState)(false), [me, fe] = (0, import_react.useState)(false), [ye, he] = (0, import_react.useState)(null), we = (0, import_react.useRef)(false), be = (0, import_react.useRef)(null), { anchorRefs: Se, setActiveAnchor: Ee } = k(l2), ge = (0, import_react.useRef)(false), [_e, Ae] = (0, import_react.useState)([]), Oe = (0, import_react.useRef)(false), Te = w2 || h2.includes("click"), ke = Te || (null == q2 ? void 0 : q2.click) || (null == q2 ? void 0 : q2.dblclick) || (null == q2 ? void 0 : q2.mousedown), Ce = q2 ? { ...q2 } : { mouseenter: true, focus: true, click: false, dblclick: false, mousedown: false };
  !q2 && Te && Object.assign(Ce, { mouseenter: false, focus: false, click: true });
  const Le = H2 ? { ...H2 } : { mouseleave: true, blur: true, click: false, dblclick: false, mouseup: false };
  !H2 && Te && Object.assign(Le, { mouseleave: false, blur: false });
  const Re = M ? { ...M } : { escape: $2 || false, scroll: z2 || false, resize: D2 || false, clickOutsideAnchor: ke || false };
  W && (Object.assign(Ce, { mouseenter: false, focus: false, click: false, dblclick: false, mousedown: false }), Object.assign(Le, { mouseleave: false, blur: false, click: false, dblclick: false, mouseup: false }), Object.assign(Re, { escape: false, scroll: false, resize: false, clickOutsideAnchor: false })), L(() => (Oe.current = true, () => {
    Oe.current = false;
  }), []);
  const xe = (e2) => {
    Oe.current && (e2 && fe(true), setTimeout(() => {
      Oe.current && (null == Z || Z(e2), void 0 === Y && ve(e2));
    }, 10));
  };
  (0, import_react.useEffect)(() => {
    if (void 0 === Y)
      return () => null;
    Y && fe(true);
    const e2 = setTimeout(() => {
      ve(Y);
    }, 10);
    return () => {
      clearTimeout(e2);
    };
  }, [Y]), (0, import_react.useEffect)(() => {
    if (pe !== we.current)
      if (ae.current && clearTimeout(ae.current), we.current = pe, pe)
        null == F || F();
      else {
        const e2 = ((e3) => {
          const t3 = e3.match(/^([\d.]+)(m?s?)$/);
          if (!t3)
            return 0;
          const [, o2, r2] = t3;
          return "s" !== r2 && "ms" !== r2 ? 0 : Number(o2) * ("ms" === r2 ? 1 : 1e3);
        })(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay"));
        ae.current = setTimeout(() => {
          fe(false), he(null), null == K || K();
        }, e2 + 25);
      }
  }, [pe]);
  const Ne = (e2) => {
    de((t3) => I(t3, e2) ? t3 : e2);
  }, $e = (e2 = _2) => {
    ie.current && clearTimeout(ie.current), me ? xe(true) : ie.current = setTimeout(() => {
      xe(true);
    }, e2);
  }, Ie = (e2 = A2) => {
    se.current && clearTimeout(se.current), se.current = setTimeout(() => {
      ge.current || xe(false);
    }, e2);
  }, je = (e2) => {
    var t3;
    if (!e2)
      return;
    const o2 = null !== (t3 = e2.currentTarget) && void 0 !== t3 ? t3 : e2.target;
    if (!(null == o2 ? void 0 : o2.isConnected))
      return Q(null), void Ee({ current: null });
    _2 ? $e() : xe(true), Q(o2), Ee({ current: o2 }), se.current && clearTimeout(se.current);
  }, Be = () => {
    R2 ? Ie(A2 || 100) : A2 ? Ie() : xe(false), ie.current && clearTimeout(ie.current);
  }, ze = ({ x: e2, y: t3 }) => {
    var o2;
    const r2 = { getBoundingClientRect: () => ({ x: e2, y: t3, width: 0, height: 0, top: t3, left: e2, right: e2, bottom: t3 }) };
    N({ place: null !== (o2 = null == ye ? void 0 : ye.place) && void 0 !== o2 ? o2 : v, offset: m, elementReference: r2, tooltipReference: ne.current, tooltipArrowReference: ce.current, strategy: b2, middlewares: S2, border: ee }).then((e3) => {
      Ne(e3);
    });
  }, De = (e2) => {
    if (!e2)
      return;
    const t3 = e2, o2 = { x: t3.clientX, y: t3.clientY };
    ze(o2), be.current = o2;
  }, qe = (e2) => {
    var t3;
    if (!pe)
      return;
    const o2 = e2.target;
    if (!o2.isConnected)
      return;
    if (null === (t3 = ne.current) || void 0 === t3 ? void 0 : t3.contains(o2))
      return;
    [document.querySelector(`[id='${d}']`), ..._e].some((e3) => null == e3 ? void 0 : e3.contains(o2)) || (xe(false), ie.current && clearTimeout(ie.current));
  }, He = g(je, 50, true), Me = g(Be, 50, true), We = (e2) => {
    Me.cancel(), He(e2);
  }, Pe = () => {
    He.cancel(), Me();
  }, Ve = (0, import_react.useCallback)(() => {
    var e2, t3;
    const o2 = null !== (e2 = null == ye ? void 0 : ye.position) && void 0 !== e2 ? e2 : V;
    o2 ? ze(o2) : O2 ? be.current && ze(be.current) : (null == J ? void 0 : J.isConnected) && N({ place: null !== (t3 = null == ye ? void 0 : ye.place) && void 0 !== t3 ? t3 : v, offset: m, elementReference: J, tooltipReference: ne.current, tooltipArrowReference: ce.current, strategy: b2, middlewares: S2, border: ee }).then((e3) => {
      Oe.current && Ne(e3);
    });
  }, [pe, J, U, P, v, null == ye ? void 0 : ye.place, m, b2, V, null == ye ? void 0 : ye.position, O2]);
  (0, import_react.useEffect)(() => {
    var e2, t3;
    const o2 = new Set(Se);
    _e.forEach((e3) => {
      o2.add({ current: e3 });
    });
    const r2 = document.querySelector(`[id='${d}']`);
    r2 && o2.add({ current: r2 });
    const l3 = () => {
      xe(false);
    }, n3 = x(J), c2 = x(ne.current);
    Re.scroll && (window.addEventListener("scroll", l3), null == n3 || n3.addEventListener("scroll", l3), null == c2 || c2.addEventListener("scroll", l3));
    let i2 = null;
    Re.resize ? window.addEventListener("resize", l3) : J && ne.current && (i2 = autoUpdate(J, ne.current, Ve, { ancestorResize: true, elementResize: true, layoutShift: true }));
    const s3 = (e3) => {
      "Escape" === e3.key && xe(false);
    };
    Re.escape && window.addEventListener("keydown", s3), Re.clickOutsideAnchor && window.addEventListener("click", qe);
    const a2 = [], u2 = (e3) => {
      pe && (null == e3 ? void 0 : e3.target) === J || je(e3);
    }, p2 = (e3) => {
      pe && (null == e3 ? void 0 : e3.target) === J && Be();
    }, v2 = ["mouseenter", "mouseleave", "focus", "blur"], m2 = ["click", "dblclick", "mousedown", "mouseup"];
    Object.entries(Ce).forEach(([e3, t4]) => {
      t4 && (v2.includes(e3) ? a2.push({ event: e3, listener: We }) : m2.includes(e3) && a2.push({ event: e3, listener: u2 }));
    }), Object.entries(Le).forEach(([e3, t4]) => {
      t4 && (v2.includes(e3) ? a2.push({ event: e3, listener: Pe }) : m2.includes(e3) && a2.push({ event: e3, listener: p2 }));
    }), O2 && a2.push({ event: "pointermove", listener: De });
    const y2 = () => {
      ge.current = true;
    }, h3 = () => {
      ge.current = false, Be();
    };
    return R2 && !ke && (null === (e2 = ne.current) || void 0 === e2 || e2.addEventListener("mouseenter", y2), null === (t3 = ne.current) || void 0 === t3 || t3.addEventListener("mouseleave", h3)), a2.forEach(({ event: e3, listener: t4 }) => {
      o2.forEach((o3) => {
        var r3;
        null === (r3 = o3.current) || void 0 === r3 || r3.addEventListener(e3, t4);
      });
    }), () => {
      var e3, t4;
      Re.scroll && (window.removeEventListener("scroll", l3), null == n3 || n3.removeEventListener("scroll", l3), null == c2 || c2.removeEventListener("scroll", l3)), Re.resize ? window.removeEventListener("resize", l3) : null == i2 || i2(), Re.clickOutsideAnchor && window.removeEventListener("click", qe), Re.escape && window.removeEventListener("keydown", s3), R2 && !ke && (null === (e3 = ne.current) || void 0 === e3 || e3.removeEventListener("mouseenter", y2), null === (t4 = ne.current) || void 0 === t4 || t4.removeEventListener("mouseleave", h3)), a2.forEach(({ event: e4, listener: t5 }) => {
        o2.forEach((o3) => {
          var r3;
          null === (r3 = o3.current) || void 0 === r3 || r3.removeEventListener(e4, t5);
        });
      });
    };
  }, [J, Ve, me, Se, _e, q2, H2, M, Te, _2, A2]), (0, import_react.useEffect)(() => {
    var e2, t3;
    let o2 = null !== (t3 = null !== (e2 = null == ye ? void 0 : ye.anchorSelect) && void 0 !== e2 ? e2 : p) && void 0 !== t3 ? t3 : "";
    !o2 && l2 && (o2 = `[data-tooltip-id='${l2}']`);
    const r2 = new MutationObserver((e3) => {
      const t4 = [], r3 = [];
      e3.forEach((e4) => {
        if ("attributes" === e4.type && "data-tooltip-id" === e4.attributeName) {
          e4.target.getAttribute("data-tooltip-id") === l2 ? t4.push(e4.target) : e4.oldValue === l2 && r3.push(e4.target);
        }
        if ("childList" === e4.type) {
          if (J) {
            const t5 = [...e4.removedNodes].filter((e5) => 1 === e5.nodeType);
            if (o2)
              try {
                r3.push(...t5.filter((e5) => e5.matches(o2))), r3.push(...t5.flatMap((e5) => [...e5.querySelectorAll(o2)]));
              } catch (e5) {
              }
            t5.some((e5) => {
              var t6;
              return !!(null === (t6 = null == e5 ? void 0 : e5.contains) || void 0 === t6 ? void 0 : t6.call(e5, J)) && (fe(false), xe(false), Q(null), ie.current && clearTimeout(ie.current), se.current && clearTimeout(se.current), true);
            });
          }
          if (o2)
            try {
              const r4 = [...e4.addedNodes].filter((e5) => 1 === e5.nodeType);
              t4.push(...r4.filter((e5) => e5.matches(o2))), t4.push(...r4.flatMap((e5) => [...e5.querySelectorAll(o2)]));
            } catch (e5) {
            }
        }
      }), (t4.length || r3.length) && Ae((e4) => [...e4.filter((e5) => !r3.includes(e5)), ...t4]);
    });
    return r2.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ["data-tooltip-id"], attributeOldValue: true }), () => {
      r2.disconnect();
    };
  }, [l2, p, null == ye ? void 0 : ye.anchorSelect, J]), (0, import_react.useEffect)(() => {
    Ve();
  }, [Ve]), (0, import_react.useEffect)(() => {
    if (!(null == X ? void 0 : X.current))
      return () => null;
    const e2 = new ResizeObserver(() => {
      setTimeout(() => Ve());
    });
    return e2.observe(X.current), () => {
      e2.disconnect();
    };
  }, [U, null == X ? void 0 : X.current]), (0, import_react.useEffect)(() => {
    var e2;
    const t3 = document.querySelector(`[id='${d}']`), o2 = [..._e, t3];
    J && o2.includes(J) || Q(null !== (e2 = _e[0]) && void 0 !== e2 ? e2 : t3);
  }, [d, _e, J]), (0, import_react.useEffect)(() => (G && xe(true), () => {
    ie.current && clearTimeout(ie.current), se.current && clearTimeout(se.current);
  }), []), (0, import_react.useEffect)(() => {
    var e2;
    let t3 = null !== (e2 = null == ye ? void 0 : ye.anchorSelect) && void 0 !== e2 ? e2 : p;
    if (!t3 && l2 && (t3 = `[data-tooltip-id='${l2}']`), t3)
      try {
        const e3 = Array.from(document.querySelectorAll(t3));
        Ae(e3);
      } catch (e3) {
        Ae([]);
      }
  }, [l2, p, null == ye ? void 0 : ye.anchorSelect]), (0, import_react.useEffect)(() => {
    ie.current && (clearTimeout(ie.current), $e(_2));
  }, [_2]);
  const Fe = null !== (le = null == ye ? void 0 : ye.content) && void 0 !== le ? le : U, Ke = pe && Object.keys(ue.tooltipStyles).length > 0;
  return (0, import_react.useImperativeHandle)(t2, () => ({ open: (e2) => {
    if (null == e2 ? void 0 : e2.anchorSelect)
      try {
        document.querySelector(e2.anchorSelect);
      } catch (t3) {
        return void console.warn(`[react-tooltip] "${e2.anchorSelect}" is not a valid CSS selector`);
      }
    he(null != e2 ? e2 : null), (null == e2 ? void 0 : e2.delay) ? $e(e2.delay) : xe(true);
  }, close: (e2) => {
    (null == e2 ? void 0 : e2.delay) ? Ie(e2.delay) : xe(false);
  }, activeAnchor: J, place: ue.place, isOpen: Boolean(me && !T2 && Fe && Ke) })), me && !T2 && Fe ? import_react.default.createElement(E2, { id: l2, role: re, className: (0, import_classnames.default)("react-tooltip", j.tooltip, B.tooltip, B[u], n2, `react-tooltip__place-${ue.place}`, j[Ke ? "show" : "closing"], Ke ? "react-tooltip__show" : "react-tooltip__closing", "fixed" === b2 && j.fixed, R2 && j.clickable), onTransitionEnd: (e2) => {
    ae.current && clearTimeout(ae.current), pe || "opacity" !== e2.propertyName || (fe(false), he(null), null == K || K());
  }, style: { ...P, ...ue.tooltipStyles, opacity: void 0 !== te && Ke ? te : void 0 }, ref: ne }, Fe, import_react.default.createElement(E2, { className: (0, import_classnames.default)("react-tooltip-arrow", j.arrow, B.arrow, s2, C2 && j.noArrow), style: { ...ue.tooltipArrowStyles, background: oe ? `linear-gradient(to right bottom, transparent 50%, ${oe} 50%)` : void 0 }, ref: ce })) : null;
};
var D = ({ content: t2 }) => import_react.default.createElement("span", { dangerouslySetInnerHTML: { __html: t2 } });
var q = (e2, t2) => !("CSS" in window && "supports" in window.CSS) || window.CSS.supports(e2, t2);
var H = import_react.default.forwardRef(({ id: t2, anchorId: r2, anchorSelect: l2, content: n2, html: s2, render: a2, className: u, classNameArrow: d, variant: p = "dark", place: v = "top", offset: m = 10, wrapper: f = "div", children: h2 = null, events: w2 = ["hover"], openOnClick: b2 = false, positionStrategy: S2 = "absolute", middlewares: E2, delayShow: g2 = 0, delayHide: _2 = 0, float: A2 = false, hidden: O2 = false, noArrow: T2 = false, clickable: C2 = false, closeOnEsc: L2 = false, closeOnScroll: R2 = false, closeOnResize: x2 = false, openEvents: N2, closeEvents: $2, globalCloseEvents: I2, imperativeModeOnly: j2 = false, style: B2, position: H2, isOpen: M, defaultIsOpen: W = false, disableStyleInjection: P = false, border: V, opacity: F, arrowColor: K, setIsOpen: U, afterShow: X, afterHide: Y, role: G = "tooltip" }, Z) => {
  const [J, Q] = (0, import_react.useState)(n2), [ee, te] = (0, import_react.useState)(s2), [oe, re] = (0, import_react.useState)(v), [le, ne] = (0, import_react.useState)(p), [ce, ie] = (0, import_react.useState)(m), [se, ae] = (0, import_react.useState)(g2), [ue, de] = (0, import_react.useState)(_2), [pe, ve] = (0, import_react.useState)(A2), [me, fe] = (0, import_react.useState)(O2), [ye, he] = (0, import_react.useState)(f), [we, be] = (0, import_react.useState)(w2), [Se, Ee] = (0, import_react.useState)(S2), [ge, _e] = (0, import_react.useState)(null), [Ae, Oe] = (0, import_react.useState)(null), Te = (0, import_react.useRef)(P), { anchorRefs: ke, activeAnchor: Ce } = k(t2), Le = (e2) => null == e2 ? void 0 : e2.getAttributeNames().reduce((t3, o2) => {
    var r3;
    if (o2.startsWith("data-tooltip-")) {
      t3[o2.replace(/^data-tooltip-/, "")] = null !== (r3 = null == e2 ? void 0 : e2.getAttribute(o2)) && void 0 !== r3 ? r3 : null;
    }
    return t3;
  }, {}), Re = (e2) => {
    const t3 = { place: (e3) => {
      var t4;
      re(null !== (t4 = e3) && void 0 !== t4 ? t4 : v);
    }, content: (e3) => {
      Q(null != e3 ? e3 : n2);
    }, html: (e3) => {
      te(null != e3 ? e3 : s2);
    }, variant: (e3) => {
      var t4;
      ne(null !== (t4 = e3) && void 0 !== t4 ? t4 : p);
    }, offset: (e3) => {
      ie(null === e3 ? m : Number(e3));
    }, wrapper: (e3) => {
      var t4;
      he(null !== (t4 = e3) && void 0 !== t4 ? t4 : f);
    }, events: (e3) => {
      const t4 = null == e3 ? void 0 : e3.split(" ");
      be(null != t4 ? t4 : w2);
    }, "position-strategy": (e3) => {
      var t4;
      Ee(null !== (t4 = e3) && void 0 !== t4 ? t4 : S2);
    }, "delay-show": (e3) => {
      ae(null === e3 ? g2 : Number(e3));
    }, "delay-hide": (e3) => {
      de(null === e3 ? _2 : Number(e3));
    }, float: (e3) => {
      ve(null === e3 ? A2 : "true" === e3);
    }, hidden: (e3) => {
      fe(null === e3 ? O2 : "true" === e3);
    }, "class-name": (e3) => {
      _e(e3);
    } };
    Object.values(t3).forEach((e3) => e3(null)), Object.entries(e2).forEach(([e3, o2]) => {
      var r3;
      null === (r3 = t3[e3]) || void 0 === r3 || r3.call(t3, o2);
    });
  };
  (0, import_react.useEffect)(() => {
    Q(n2);
  }, [n2]), (0, import_react.useEffect)(() => {
    te(s2);
  }, [s2]), (0, import_react.useEffect)(() => {
    re(v);
  }, [v]), (0, import_react.useEffect)(() => {
    ne(p);
  }, [p]), (0, import_react.useEffect)(() => {
    ie(m);
  }, [m]), (0, import_react.useEffect)(() => {
    ae(g2);
  }, [g2]), (0, import_react.useEffect)(() => {
    de(_2);
  }, [_2]), (0, import_react.useEffect)(() => {
    ve(A2);
  }, [A2]), (0, import_react.useEffect)(() => {
    fe(O2);
  }, [O2]), (0, import_react.useEffect)(() => {
    Ee(S2);
  }, [S2]), (0, import_react.useEffect)(() => {
    Te.current !== P && console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.");
  }, [P]), (0, import_react.useEffect)(() => {
    "undefined" != typeof window && window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles", { detail: { disableCore: "core" === P, disableBase: P } }));
  }, []), (0, import_react.useEffect)(() => {
    var e2;
    const o2 = new Set(ke);
    let n3 = l2;
    if (!n3 && t2 && (n3 = `[data-tooltip-id='${t2}']`), n3)
      try {
        document.querySelectorAll(n3).forEach((e3) => {
          o2.add({ current: e3 });
        });
      } catch (e3) {
        console.warn(`[react-tooltip] "${n3}" is not a valid CSS selector`);
      }
    const c2 = document.querySelector(`[id='${r2}']`);
    if (c2 && o2.add({ current: c2 }), !o2.size)
      return () => null;
    const i2 = null !== (e2 = null != Ae ? Ae : c2) && void 0 !== e2 ? e2 : Ce.current, s3 = new MutationObserver((e3) => {
      e3.forEach((e4) => {
        var t3;
        if (!i2 || "attributes" !== e4.type || !(null === (t3 = e4.attributeName) || void 0 === t3 ? void 0 : t3.startsWith("data-tooltip-")))
          return;
        const o3 = Le(i2);
        Re(o3);
      });
    }), a3 = { attributes: true, childList: false, subtree: false };
    if (i2) {
      const e3 = Le(i2);
      Re(e3), s3.observe(i2, a3);
    }
    return () => {
      s3.disconnect();
    };
  }, [ke, Ce, Ae, r2, l2]), (0, import_react.useEffect)(() => {
    (null == B2 ? void 0 : B2.border) && console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."), V && !q("border", `${V}`) && console.warn(`[react-tooltip] "${V}" is not a valid \`border\`.`), (null == B2 ? void 0 : B2.opacity) && console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."), F && !q("opacity", `${F}`) && console.warn(`[react-tooltip] "${F}" is not a valid \`opacity\`.`);
  }, []);
  let xe = h2;
  const Ne = (0, import_react.useRef)(null);
  if (a2) {
    const t3 = a2({ content: (null == Ae ? void 0 : Ae.getAttribute("data-tooltip-content")) || J || null, activeAnchor: Ae });
    xe = t3 ? import_react.default.createElement("div", { ref: Ne, className: "react-tooltip-content-wrapper" }, t3) : null;
  } else
    J && (xe = J);
  ee && (xe = import_react.default.createElement(D, { content: ee }));
  const $e = { forwardRef: Z, id: t2, anchorId: r2, anchorSelect: l2, className: (0, import_classnames.default)(u, ge), classNameArrow: d, content: xe, contentWrapperRef: Ne, place: oe, variant: le, offset: ce, wrapper: ye, events: we, openOnClick: b2, positionStrategy: Se, middlewares: E2, delayShow: se, delayHide: ue, float: pe, hidden: me, noArrow: T2, clickable: C2, closeOnEsc: L2, closeOnScroll: R2, closeOnResize: x2, openEvents: N2, closeEvents: $2, globalCloseEvents: I2, imperativeModeOnly: j2, style: B2, position: H2, isOpen: M, defaultIsOpen: W, border: V, opacity: F, arrowColor: K, setIsOpen: U, afterShow: X, afterHide: Y, activeAnchor: Ae, setActiveAnchor: (e2) => Oe(e2), role: G };
  return import_react.default.createElement(z, { ...$e });
});
"undefined" != typeof window && window.addEventListener("react-tooltip-inject-styles", (e2) => {
  e2.detail.disableCore || S({ css: `:root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}`, type: "core" }), e2.detail.disableBase || S({ css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`, type: "base" });
});
export {
  H as Tooltip,
  T as TooltipProvider,
  C as TooltipWrapper,
  E as removeStyle
};
/*! Bundled license information:

react-tooltip/dist/react-tooltip.min.mjs:
  (*
  * React Tooltip
  * {@link https://github.com/ReactTooltip/react-tooltip}
  * @copyright ReactTooltip Team
  * @license MIT
  *)
*/
//# sourceMappingURL=react-tooltip.js.map
